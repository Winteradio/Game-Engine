
[ 2023-03-18 ]

template< class T >

#include <iostream>

class ResourceManager
{

	template< class T >
	static void CreateMap()
	{
		m_ResourceData[ &typeid( T ) ] = std::map< std::string, IResource* >();
	}

	template< class T >
	static void CreateResource( std::string Name )
	{
		UUID Id;
		IResource* Temp = new T( Name, ID );
		m_ResourceData[ typeid(T).name() ][ ID ] = Temp;
	}

	template< class T >
	static T* GetResource( std::string ID )
	{
		return (T*)m_ResourceData[ typeid(T).name()][ ID ];
	}
	
	template< class T >
	static std::map< std::string, IResource* > > GetMap()
	{
		return m_ResourceData[ typeid(T).name() ];
	}

	std::map< std::string, std::map< std::string, IResource* > > m_ResourceData;	

	std::map< const type_info&, std::map
};

class ResourceGuiLayer
{
	template< class T >
	void RenderTree()
	{
		if ( ImGui::TreeNode( typeid(T).name().c_str() );
		for ( auto itr = ResourceManager::GetMap<T>().begin(); itr != ResourceManager::GetMap<T>().end(); itr++ )
		{
			if ( ImGui::Selectable( itr->GetName().c_str() ) )
			{
				m_PropertyGuiLayer->Render<T>( (T*)itr );
			}
		}
		ImGui::PopNode();
	}
}

class PropertyGuiLayer
{
	void RenderCommon( IResource* Resource )
	{
		ImGui::Text( Resource->GetName().c_str() );
		ImGui::Text( Resource->GetID().c_str() );
		ImGui::Text( Resource->GetType().c_str() );
	}

	void RenderProperty( Scene* Resource )
	{
		...
	}

	void RenderProperty( Component* Resource )
	{
		...
	}
		...

	template< class T >
	void Render( T* Resource )
	{
		RenderCommon();
		RenderProperty( Resource );
	}

	->> SettingGuiLayer, FileSystemGuiLayer처럼 Begin과 End로 구현하기
}

- >> Done


class IResource
{
	std::string m_Name;
	std::string m_UUID;
};

[ 2023-03-21 ]

- Input New Object
GuiLayer ->(Change) IGuiLayer

IBrowserGuiLayer <-(Inheritance) IGuiLayer

MenuBrowserGuiLayer <-(Inheritance) IBrowserGuiLayer
	->> MainGuiLayer

PropertyBrowserGuiLayer <-(Inheritance) IBrowserGuiLayer
	->> PropertyGuiLayer

FileBrowserGuiLayer <-(Inheritance) IBrowserGuiLayer
	->> FileSystemGuiLayer

ProjectManager
	->> Manager Yaml File

- File Browser system
	-> IBrowserGuiLayer
		->> Menu ... ( MenuBrowserGuiLayer )
		->> Property ... ( PropertyBrowserGuiLayer )

		Click selectable for button like "File Load",
		then, Begin FileBrowserGuiLayer

	-> FileBrowserGuiLayer
		Render files and user select path ...
		As result, user click "Done" button,
		then call IBrowserGuiLayer end

	-> MenuBrowserGuiLayer
		if it is called by FileBrowserGuiLayer,
		Call ProjectManager

	-> PropertyBrowserGuiLayer
		if it is called by FileBrowserGuiLayer,
		Call Resource's Compile( FS::path Path ) function


- Change Resource System
	-> ResourceManager
		- Resource must be accessed by ResourceManager,
		because, the other method is existed that access to resource,
		the other method must copy resource's pointer data and
		the other method must overlap ResourceManager

	-> Scene
		- It has map data structure that has typeinfo and UUID vector

	-> Component
		- It has map data structure that has typeinfo and UUId vector


[ 2023-04-01 ]
class SceneManager
{
private :
	SceneManager() {};
	~SceneManager() {};

public :
	void Init() {};
	void Destroy() {};

	static std::vector< Scene >& GetScenes()
	{
		return m_SceneManager.m_SceneData;
	}

	static void SetScene( Scene Other )
	{
		m_SceneManager.m_SceneData.push_back( Other );
	}

private :
	static SceneManager m_SceneManager;
	std::vector< Scene > m_SceneData;
};

class RenderSystem;
class CollisionCheckSystem;

class Scene
{
	public :
		Scene() {};
		~Scene() {};

	public :
		void Init()
		{
			R
		}

		void RegitserEntity( Entity& OtherEntity )
		{

		}

		void RegisterComponent( Component& OtherComponent )
		{

		}

		void RegisterSystem( System& OtherSystem )
		{

		}

		void OnUpdate()
		{

		}
};

class Entity
{
	public :
		Entity() {};
		virtual ~Entity(){};

	public :
		virtual void Update() = 0;
};

struct Component
{

};

class System
{
	public :
		System() {};
		virtual ~System() {};

	public :
		virtual void Init() = 0;
		virtual void Update() = 0;
};

struct Transformation
{
	XMFLOAT3 Position;
	XMFLOAT3 Rotation;
	XMFLOAT3 Scale;
};

struct FilePath
{
	FS::path Path;
};

struct Mesh
{
	VertexBuffer;
	IndexBuffer;
};

struct Renderable
{
	Trnasformation* m_Transform;
	Mesh* m_Mesh;
};

[ 2023-04-07 ]

// Component들
struct IDComponent
{
	MyUUID ID;
};

struct TagComponent
{
	std::string Name;
};

struct TransformComponent
{

};

// Entity 객체
class Entity
{
	public :

	public :
		void AddComponent();

};

// Node들
struct RenderableNode
{

};

struct CameraNode
{

};

struct LightNode
{

};

// System들
class RenderingSystem
{

};

[ 2023-04-09 ]

Entity
	-> Component에 대한 주소들을 지니고 있음
	-> 단순히, Component들을 등록 및 해제할 수 있음

Component
	-> 특성들을 지니고 있음

Node
	-> Archtype이라고 생각하면 될 듯
	-> System으로 넘겨야 되는, 각 Entity에 따른 Component들의 묶음이라고 생각
	-> Component에 대한 주소들을 지니고 있음
	-> Entity에 속한 작은 Entity라고 생각하면 될 듯

Scene ( Entity Manager )
	-> Entity들을 관리
	-> Entity 생성 및 삭제

Component Manager
	-> Component들의 실제 인스턴스들을 저장
	-> Component들을 생성 및 삭제

Node Manager
	-> Node들의 실제 인스턴스들을 저장
	-> Node들에게 해당 Entity들을 넘겨주는 역할( Scene에서 받아옴 )

의문점
	1. Entity들은 어떻게 해서 자신이 가져야 할 Node들의 정보를 알 수 있지?
		1.1 사용자가 설정할 수 있도록 해야한다.
		1.2 해당 Entity가 어떤 Node들을 가지고 System에 연결할 지 어떻게 할 것인가?
		1.3 Proj 파일 안에서 해당 Entity들이 어떤 Node들에 연결이 될 지 나타낼 수 있다.
	2. 해당 Node들과 System들은 보통은 1대1로 매칭시키자

	3. Blue Print처럼 Node들을 연결시킬 수 있는 Visual Graph를 구현하는 것이 좋을까?
		3.1 연결에 대한 정보는 Proj 파일에 들어가 있도록 구현을 해보자
		3.2 만약에 연결을 직접 해야한다면 어떻게 해야할까?
		3.3 Visual Graph가 없을 때는 어떤식으로 구현할지 생각을 해보자.

[ 2023-04-10 ]
1. 차세대 Unit의 기반 기술
2. Data Oriented Design( DOD ) 으로의 전환
3. ECS, Job System. Burst Compiler 세가지 요소의 합
4. 복잡한 코드없이 간단하게 Multi-Threading이 가능
5. 빌드 옵션 하나로 퍼모먼스 향상

# Entity, Component, System
	-> DOD를 위해 제공되는 아키텍쳐
	-> Entity는 데이터를 가리키는 인덱스
	-> Component는 읽고 쓰기 위한 데이터
	-> System에서 Entity와 Component를 가지고 로직을 구현
	-> Entity와 Component만 있다면 아무 일도 일어나지 않음

# Job System
	-> Multi-Threading을 가능하게 하는 시스템
	-> Race Condition 걱정없이 Threading 구현이 가능
	-> 코드상의 이름은 Job Component System
	-> Job들을 생성하고 의존성에 대한 Handle을 반환
	-> 작업 방식에 따라 여러 형태의 Job을 제공

#1. Entity
-> ID들을 지니고 있다.
-> Component들에 대한 포인터를 지니고 있다.

#2. Component
-> 실제의 Attribute들을 지니고 있다.

#3. Node
-> 해당된 Entity의 ID를 등록한다
-> Component들의 포인터를 지니고 있다.
	-> Node들을 어떻게 해서 Caching Hit를 높일지는 나중에 생각을 해보자.

#4. System
-> 필요로 하는 Node들을 가지고 Update를 진행한다.

struct Component
{
// attribute for entities
};

class Entity
{
// Register Component;
// Make Entity ID;
};

struct Node
{
// This is component collection
};

[ 2023-04-11 ]

#1. Map 구조
	-> Component Manager
		Key : Component Type 정보
		Value : std::any
			-> std::vector< Type >
			-> std::any_cast 를 사용해서 구현을 해보자.

		or C++17 이하와의 호환성을 위해서
		Value : void*
			-> std::vector< Type >

	-> Entity
		Key : Component Type 정보
		Value : void*

	-> Scene
		Key : MyUUID
		Value : Entity

	-> Scene Manager
		Key : MyUUID
		Value : Scene

	-> Node Manager
		Key : Node Type 정보
		Value : std::any
			-> std::vector< Type >

		or C++17 이하와의 호환성을 위해서
		Value : void*
			-> std::vector< Type >

		하지만 이미 typeinfo를 사용해서 C++17 이상만 사용가능한 것 아닌가?

	-> void* reinterpret_cast vs std::any
		-> reinterpret_cast 포인터 간의 형변환
			-> 잘못된 변화일 때의 경우, 막아주는 것이 없다.

		-> std::any
			-> 잘못된 변환일 때, 막아줄 수 있게 해준다.

	-> map 자체는 그냥 48 바이트의 크기를 지닌다.
		실제 map 객체 전체의 데이터의 크기는
		Key + Value * map pair 개수 + map instance 사이즈이다.

		pair 데이터의 경우에는 Heap에 저장되고( 동적 )
		map 객체 자체이 경우에는 Stack에 저장( 정적 )
		익 대문에, map 객체 자체에 대한 사이즈는 48로 일정할 수 밖에 없다.

	-> Layer들의 경우에는 Component에 따라서 Rendering 해주는 Property Layer가 존재하고
	-> Scene들을 다루는 Scene Layer
	-> Log들만을 주로 다루는 Log Layer
	-> Main Menu Layer가 존재하게 된다.


Entity
	-> ID
	-> Component's Pointer

Node
	-> Id
	-> Component's Pointer

Componen Manager
	-> Type Component Instance

Node Manager
	-> Type Node Instance

Scene
	-> ID
	-> Entity Instance


[ 2023-04-12 ]

# Entity
	-> ID
	-> Components' Pointer

# Node
	-> ID
	-> Components' Pointer

# Component Manager
	-> Each Type of Component Instance
	-> std::any or void* : std::vector

# Node Manager
	-> Each Type of Node Instance
	-> std::any or void* : std::vector

# Scene
	-> ID
	-> Entities' Instance

# Scene
	-> Scenes' Instance

# System
	-> The Function uses some type of Node
	-> The System Needs very complex, and 
	each system cannot contact each other,
	just connect through node
	
# System Manager
	-> Systems' Instance
	-> Register System
	-> Systems must be inheritance ISystem that has init,set and frame function's interface
	-> System Manager set sequence of System on frame
	
	# ISystem
		-> That is the interface of system
		-> This Object has some pointer of prev, next ISystem.
		-> Cause, System must have seqeunce during frame animation
		-> For example, Collision Animation has first collision System,
		Second CalculatePhysicsSystem, lastly RenderSystem.
		-> So, if this sequence is linked list, the User using this engine,
		more easily edit sequence, some system input or delete ... 
		and, user can see thie sequence on game engine ui.
		So, the User drag some system for inputting this sequence, 
		just, connect prev system and next system.
